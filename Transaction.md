# Gunero Transaction Structure

## Definitions

### Account Address and Key
"Account Address" or account refers to the 160-bit identifier used to uniquely identify an
Ethereum given a EDCSA public-private key pair. It is the first 20-bytes of the keccak256
hash of the public key.

Represented as: `A_account` (account public address) and `s_account` (account private key),
where `account` is one of sender (`S`), receiver (`R`), or previous sender (`PS`)

### Authorization Root Hash
The "Authorization Root Hash" is the root hash of the sparse merkle tree data structure used to track
the authorization status of accounts in the system. The key used for obtaining this root hash is the
Ethereum account address `A_account`, and the status is at the leaf.

Represented as: `W` (`W_P` used for "previous auth root hash") and `N_account` (status of account)

### Authorization Merkle Path
The root hash of a merkle tree can be used to generate proofs of inclusion. This is done by providing
a list of sibling nodes that traverse up the tree. The proof starts at the leaf, which is first hashed
into the starting node, and then hashes are recursively computed from that hash and the sibling at level
`i` of the tree until it reaches the root (at level 0). The order that the data is hashed in is determined
by the path, which is a list of boolean orderings obtained from the key of the data structure (every `i`-th
bit in the integer). If the final hash matches a given root hash `W`, we know the data is consistent.

Represented as: `M_account[i]` (`[i]` denotes an array of length `i`)

### Account View Hash and Randomizer
In order to tie the authorization proof (which is generated once per Plasma cycle),
to the specific transaction in which a token is spent without incurring prohibitive
overhead on the transaction process, we need to define a public parameter that is shared
between the proofs verifying that the Account used to generate the authorization
proof is the same account specified in the given transaction. The "view hash" is this
data structure, protected from pre-imaging attacks from the use of a randomized secret
called the "randomizer" that is never publicly divulged. The view hash is re-computed every cycle,
but can be safely used multiple times within a given cycle to participate in different trades.

Represented as: `V_account` (view hash) and `r_account` (randomizer)

The view hash is computed as follows:
```
V_account = hash(A_account + W + r_account)
```

### Token Unique Identifier
In order to obfuscate the serial numbers being traded on GunClear's network from surveilance, we hide
the serial number with a unique and uncorrelated identifier called a "Token UID". This identifier is
generated by the first account that originally "tokenized" the firearm, and is constructed from the
serial number of the firearm, and a "Firearm View Randomizer" which is a randomly generated number.
This number is shared between all owners of the firearm and can be used to verify, prior to trading,
that an owner actually "owns" that firearm, similar to 2FA (something you have and something you know).

Represented as: `T` (Token UID) and `j` (Firearm View Randomizer)

The Token UID is computed as follows:
```
T = hash(F + j)
```
where `F` is the firearm's serial number, in a standardized numerical format (which may be pre-processed)

### Transaction Hash
The transaction hash is what the Gunero operators use to track the current state of ownership of a given firearm token.
It is used as a commitment/nullifier in a similar fashion to Zcash; however, since we do not have a need to perform
join-split transactions, we were able to reduce it to a single spending commitment based on the owner's private key.

Represented as: `txn` (`txn_P` is used for previous)

This hash is computed as follows:
```
txn = hash(A_S + s_R + T + W)
```

## Authorization Proof (Both Parties Generate)

### Public Parameters
* Authorization Root Hash (`W`)
* Account Status (`N_account`)
* Account View Hash (`V_account`)

### Private Parameters
* Account Secret Key (`s_account`)
* Authorization Merkle Path (`M_account[160]`)
* Account View Randomizer (`r_account`)

### Proof Steps
1. Obtain `A_account` from `s_account` through EDCSA operations.
2. Validate `W == calc_root(A_account, N_account, M_account[160])`
3. Validate `V_account == hash(A_account + W + r_account)`

## Transaction Receive Proof (Receiver Generates)

### Public Parameters
* Authorization Root Hash (bytes32 hash)
* Token UID (bytes32 hash)
* Sender Account View Hash (bytes32 hash)
* Receiver Account View Hash (bytes32 hash)
* Current Transaction Hash (bytes32 hash)

### Private Parameters
* Receiver Private Key (uint252 plain)
* Receiver Account View Randomizer (uint128 plain)
* Sender Account Address (bytes20 hash)
* Sender Account View Randomizer (uint128 plain)
* Firearm Serial Number (bytes16 hash)
* Firearm View Randomizer (uint128 plain)

## Transaction Send Proof (Sender Generates)

### Public Parameters
* Current Authorization Root Hash (bytes32 hash)
* Token UID (bytes32 hash)
* Sender Account View Hash (bytes32 hash)
* Receiver Account View Hash (bytes32 hash)
* Previous Transaction Hash (bytes32 hash)

### Private Parameters
* Sender Private Key (uint252 plain)
* Sender Account View Randomizer (uint128 plain)
* Receiver Account View Randomizer (uint128 plain)
* Previous Sender Account Address (bytes20 hash)
* Previous Authorization Root Hash (bytes32 hash)

## Transaction Setup
In setting up a transaction, the sender must share the following with the receiver:
* Sender Account Address (bytes20 hash)
* Sender Account View Hash (bytes32 hash)
* Sender Account View Randomizer (uint128 plain)
* Firearm Serial Number (bytes16 hash)
* Firearm View Randomizer (uint128 plain)

The sender should share the following with the receiver (not strictly required):
* Sender Account Status (uint2 plain)
* Sender Authorization Proof

The receiver must share the following with the sender:
* Receiver Account Address (bytes20 hash)
* Receiver Account View Hash (bytes32 hash)
* Receiver Account View Randomizer (uint128 plain)
* Receiver Authorization Proof

## Network Format
### Provided with Transaction
This is the structure of the transaction communicated over the network:
* Token UID (bytes32 hash)
* Current Transaction Hash (bytes32 hash)
* Sender Account View Hash (bytes32 hash)
* Receiver Account View Hash (bytes32 hash)
* Sender Account Status (uint2 plain)
* Receiver Account Status (uint2 plain)
* Sender Authorization Proof
* Receiver Authorization Proof
* Transaction Receive Proof
* Transaction Send Proof

### Known Environment Parameters
The network operators and all other parties will know the following information,
given the information provided along with a transaction:
* Previous Transaction Hash (bytes32 hash)
* Current Authorization Root Hash (bytes32 hash)
